##### PredictTargets.R   Predict magnitudes of Target (unknown) stars in Astronight's master data frame.
#####    Uses this Astronight's lmer() model object etc from Model.R::modelAll().

predictAll <- function (AN_top_folder="J:/Astro/Images/C14", AN_rel_folder=NULL, 
                        saturatedADU=54000, maxMagUncertainty=0.05, CI_filters=c("V","I")) {
  ##### Performs ALL steps to get transformed magnitudes for Check and Target observations in df_master.
  ##### Returns big data frame df_predict (which is transformed).
  ##### Requires that AN folder contain R files df_master.Rdata (from Input.R::make_df_master()) and 
  #####    masterModelList.Rdata (from Model.R::make_masterModelList()).
  ##### Typical usage: df_predictions <- predictAll(AN_rel_folder="20151216")
  if (is.null(AN_rel_folder)) {stop(">>>>> You must provide a AN_rel_folder, ",
                                  "e.g., AN_rel_folder='20151216'.")}
  source("C:/Dev/Photometry/$Utility.R")
  AN_folder   <- make_safe_path(AN_top_folder, AN_rel_folder)
  photometry_folder <- make_safe_path(AN_folder, "Photometry")
  path_df_master <- make_safe_path(photometry_folder, "df_master.Rdata")
  load(path_df_master, verbose=TRUE)
  path_masterModelList <- make_safe_path(photometry_folder, "masterModelList.Rdata")
  load(path_masterModelList, verbose=TRUE)
  
  # Select Target and Check rows for which CatMag to be predicted (all filters).
  # Make df of all needed inputs (newdata) for all filters & all (untransformed) lme4::predict() calls.
  require(dplyr, quietly=TRUE)
  df_predict_input <- df_master %>%
    filter(StarType %in% c("Check","Target")) %>%
    filter(UseInModel==TRUE) %>%
    filter(MaxADU<=saturatedADU) %>%
    filter(MagUncertainty<=maxMagUncertainty) %>%
    mutate(CI=ifelse(is.na(CI),0,CI)) %>%
    select(Serial, ModelStarID, StarID, Chart, Xpixels, Ypixels, InstMag, MagUncertainty, StarType,
           JD_mid, Filter, Airmass, CI, Vignette, Vignette4) %>%
    mutate(CatMag=0) # arbitrarily chosen, to complete model.

  # Get untransformed predicted Inst Mags (via running predict(), collecting all results).
  df_predictions <- data.frame()
  require(lme4, quietly = TRUE)
  for (thisModelList in masterModelList) {
    df_thisFilter <- df_predict_input %>% filter(Filter==thisModelList$filter)
    predictOutput <- predict(thisModelList$model, newdata=df_thisFilter, re.form=~(1|JD_mid))
    # Add extinction*airmass term if not included in model (as formula term "Airmass").
    if (!thisModelList$fit_extinction) {
      predictOutput <- predictOutput + extinction * df_thisFilter$Airmass
    }
    df_predictions_thisFilter <- df_thisFilter %>%
      mutate(PredictedInstMag = predictOutput)
    df_predictions <- rbind(df_predictions, df_predictions_thisFilter)
  }

  # Impute UntransformedMags from PredictedInstMag and InstMag (and CatMag=0).
  df_predictions <- df_predictions %>%
    mutate(UntransformedMag = InstMag - PredictedInstMag)
  
  # Impute Color Index values for target observations by interpolation.
  transforms <- c(masterModelList[[CI_filters[1]]]$transform, masterModelList[[CI_filters[2]]]$transform)
  df_predictions <- imputeTargetCIs(df_predictions, CI_filters, transforms) # Fill in CI values for targets.
  
  # Perform color transformations.
  df_xref_transform <- data.frame(stringsAsFactors=FALSE) # build a lookup table to get Transforms.
  for (thisModelList in masterModelList) {
    df_xref_transform <- df_xref_transform %>%
      rbind(data.frame(Filter=thisModelList$filter, Transform=thisModelList$transform))
  }
  df_xref_transform$Filter <- as.character(df_xref_transform$Filter)
  df_transformed <- df_predictions %>%
    left_join(df_xref_transform, by="Filter") %>%
    mutate(TransformedMag = UntransformedMag - Transform * CI) # minus is the correct sign: 20160206.

  # Compute MagErr (for AAVSO).
  df_xref_modelSigma <- data.frame(stringsAsFactors=FALSE) # build a lookup table to get model mag errs
  for (thisModelList in masterModelList) {
    df_xref_modelSigma <- df_xref_modelSigma %>%
      rbind(data.frame(Filter=thisModelList$filter, ModelSigma=sigma(thisModelList$model)))
  }
  df_xref_modelSigma$Filter <- as.character(df_xref_modelSigma$Filter)
  df_transformed <- df_transformed %>%
    left_join(df_xref_modelSigma, by="Filter") %>%
    mutate(MagErr = pmax(ModelSigma, MagUncertainty)) # pmax = "parallel" element-wise max of 2 vectors
  
  df_transformed <- df_transformed %>% arrange(ModelStarID, JD_num)
  
  # Save df_transformed as .Rdata file (but do not return it).
  path_transformed <- make_safe_path(photometry_folder, "df_transformed.Rdata")
  save(df_transformed, file=path_transformed, precheck=FALSE)
  
  # Make a template-only report_map.txt file if report_map.txt doesn't already exist.
  path_report_map <- make_safe_path(photometry_folder, "report_map.txt")
  if (!file.exists(path_report_map)) {
    lines <- c(
      paste0(";----- This is report_map.txt for AN folder ", AN_rel_folder),
      paste0(";----- Use this file to combine and/or omit target observations from AAVSO report."),
      paste0(";----- Example directive lines:\n"),
      paste0(";"),
      paste0(";"),
      paste0(";"),
      paste0(";"),
      paste0(";\n;----- Add your directive lines:\n;\n\n")
    )
    writeLines(lines, con=path_report_map)
  }
  nTargetObs <- df_transformed %>% filter(StarType=="Target") %>% nrow()
  nTargets   <- df_transformed %>% filter(StarType=="Target") %>% select(ModelStarID) %>% 
    unique() %>% nrow()
  nCheckObs  <- df_transformed %>% filter(StarType=="Check") %>% nrow()
  Filters    <- df_transformed %>% filter(StarType=="Target") %>% select(Filter) %>% 
    unique()
  cat("PredictAll() yields", nTargetObs, "Target obs for", nTargets, "in filters:", 
      paste(Filters,collapse=" ","\n"))
  cat("   and ", nCheckObs, " Check observations.\n")

  cat("Transformed predictions saved to", path_transformed, "\n",
      "   and report_map.txt is ensured available in the same folder\n",
      "Now you are ready to:\n",
      "   1. run targetPlots(),\n",
      "   2. group/select target observations in report_map.txt, repeat 1 & 2 as needed\n",
      "   3. run AAVSO() to make report, and\n",
      "   4. submit report to AAVSO.")
  return(df_transformed)
}
  
AAVSO <- function (AN_top_folder="J:/Astro/Images/C14", AN_rel_folder=NULL) {
  ##### Writes AAVSO-ready text file.
  ##### No return value.
  ##### First testing 20160207.
  require(dplyr, quietly=TRUE)
  if (is.null(AN_rel_folder)) {stop(">>>>> You must provide a AN_rel_folder parm, ",
                                  "e.g., AN_rel_folder='20151216'.")}
  
  out <- "#TYPE=EXTENDED" %>%
    c("#OBSCODE=DERA") %>% #       DERA = Eric Dose's observer code @ AAVSO
    c("#SOFTWARE=custom R Scripts, github/edose") %>%
    c("#DELIM=,") %>%
    c("#DATE=JD") %>%
    c("#OBSTYPE=CCD") %>%
    c("#NAME,DATE,MAG,MERR,FILT,TRANS,MTYPE,CNAME,CMAG,KNAME,KMAG,AMASS,GROUP,CHART,NOTES")

  AN_folder   <- make_safe_path(AN_top_folder, AN_rel_folder)
  photometry_folder <- make_safe_path(AN_folder, "Photometry")
  
  # Get and reformat df_report.
  df_report <- make_df_report(photometry_folder)
  df_report <- make_df_report(photometry_folder) %>%
    mutate(TargetName = TargetName %>% trimws() %>% toupper()) %>%
    mutate(JD         = JD         %>% as.numeric() %>% round(5) %>% format(nsmall=5)) %>%
    mutate(Mag        = Mag        %>% round(3) %>% format()) %>%
    mutate(MagErr     = MagErr     %>% round(3) %>% format()) %>%
    mutate(Filter     = Filter     %>% trimws() %>% toupper()) %>%
    mutate(CompName   = CompName   %>% trimws() %>% toupper()) %>%
    mutate(CompMag    = ifelse(CompMag=="na","na",CompMag      %>% round(3) %>% format())) %>%
    mutate(CheckName  = ifelse(is.na(CheckName),"na",CheckName %>% trimws() %>% toupper())) %>%
    mutate(CheckMag   = ifelse(is.na(CheckMag), "na",CheckMag  %>% round(3) %>% format())) %>%
    mutate(Airmass    = Airmass    %>% round(4) %>% format()) %>%
    mutate(Chart      = Chart      %>% trimws() %>% toupper()) %>%
    mutate(Notes      = ifelse(trimws(Notes)=="","na",trimws(Notes)))
  
  # Append rows of df_report to character vector "out".
  obs_lines <- paste(
    df_report$TargetName,
    df_report$JD,
    df_report$Mag,
    df_report$MagErr,
    df_report$Filter,
    "YES",                   # always Transformed for full model.
    "STD",                   # we use standard comp stars, not "differential" mode.
    df_report$CompName,      # ="ENSEMBLE" when more than one comp star for this observation.
    df_report$CompMag,       # "na" if Ensemble comp, else instrument comp mag (or maybe "na" even so).
    df_report$CheckName,
    df_report$CheckMag,
    df_report$Airmass,
    "na",                   # GROUP, not used here.
    df_report$Chart,
    df_report$Notes,
    sep=",")
  out <- out %>% c(obs_lines)

  # Now dump the char vector "out" to a text file.
  filename_report <- "AAVSOreport.txt"
  path_report   <- make_safe_path(photometry_folder, filename_report)
  write(out,file=path_report)
  cat(paste0("AAVSO report for AN ",AN_rel_folder," written to: ", path_report, "\n   = ",
    length(obs_lines)," observations."))
}


################################################################################################
##### Below are support-only functions, not called by user. ####################################

make_df_report <- function(photometry_folder) {
  ##### Inputs: df_transformed, masterModelList.
  ##### Returns: df_report for AAVSO().
  ##### In development EVD Feb 6, 2016.
  require(dplyr, quietly=TRUE)
  
  path_df_transformed <- make_safe_path(photometry_folder, "df_transformed.Rdata")
  load(path_df_transformed, verbose=TRUE)
  path_masterModelList <- make_safe_path(photometry_folder, "masterModelList.Rdata")
  load(path_masterModelList, verbose=TRUE)
  
  df_report <- df_transformed %>%
    select(Serial, StarType, TargetName=StarID, JD=JD_mid, Mag=TransformedMag, MagErr, Filter) %>%
    mutate(CompName=NA, CompMag=NA, CheckName=NA, CheckMag=NA) %>%
    mutate(Airmass=df_transformed$Airmass, Chart=df_transformed$Chart, Notes="") %>%
    filter(StarType=="Target") %>% # need to do this late to keep df_report & df_transformed aligned.
    select(-StarType)
           
  # Read report_map.txt and arrange actions.
  # POSTPONE.
  
  # Apply report_map.txt omissions before any other manipulations.
  # POSTPONE.
  
  # Apply check-star names and mags (lookup from df_transformed, then insert column in-place).
  df_checks <- df_transformed %>% filter(StarType=="Check") %>% select(JD_mid, StarID, TransformedMag)
  df_joined <- df_report      %>% left_join(df_checks, by=c("JD"="JD_mid"))
  df_report <- df_report      %>% mutate(CheckName=df_joined$StarID, CheckMag=df_joined$TransformedMag)
  
  # Apply comp-star names and mags.
  # Make df_comps by rbind() all $obs from masterModelList
  df_comps <- data.frame(stringsAsFactors=FALSE)
  for (thisModelList in masterModelList) {
    df_thisComp <- thisModelList$obs %>% filter(StarType=="Comp") %>% select(Serial,JD_mid,StarID,Filter)
    df_comps <- df_comps %>% rbind(df_thisComp)
  }
  # Now insert comp info.
  reportJDs <- (df_report %>% arrange(JD))$JD %>% unique()
  for (thisJD in reportJDs) {
    df_compsThisJD <- df_comps %>% filter(JD_mid==thisJD)
    if (nrow(df_compsThisJD)<=0) {
      stop(">>>>> No comp stars in model for JD = ", thisJD)
    }
    if(nrow(df_compsThisJD) > 1) { 
      # the ensemble case.
      df_report$CompName[df_report$JD==thisJD] <- "ENSEMBLE"
      df_report$CompMag[df_report$JD==thisJD]  <- "na"
      df_report$Notes[df_report$JD==thisJD]    <- paste0(nrow(df_compsThisJD)," comps")
    } else { 
      # the single-comp-star case.
      df_report$CompName[df_report$JD==thisJD] <- df_compsThisJD$StarID[1]
      df_report$CompMag[df$reportJD==thisJD]  <- "na" # unsure what AAVSO's "Inst Mag of Comp Star" means.
    }
    i <- 1 # to look at df_report
  }
  

  # Apply report_map.txt #COMBINE directive lines (careful with the check and comp stars associated).
  # POSTPONE.
  
  
  
  
  return(df_report) # return without final formatting for AAVSO report (leave that to AAVSO() function).
}

imputeTargetCIs <- function (df_predictions, CI_filters, transforms) {
  # Impute Color Index CI (=true V Mag - true I Mag) from untransformed mags.
  require(dplyr, quietly=TRUE)
  JD_floor <- floor(min(as.numeric(df_predictions$JD_mid)))
  df_predictions <- df_predictions %>% mutate(JD_num=as.numeric(JD_mid)-JD_floor) # avoid scaling problems.
  
  targetStarIDs <- (df_predictions %>%
    filter(StarType=="Target"))$ModelStarID %>%
    unique()
  
  for (thisTargetStarID in targetStarIDs) { # handle one target's ModelStarID at a time.
    df_targetStarID <- df_predictions %>% 
      filter(ModelStarID==thisTargetStarID) %>%
      select(Serial, ModelStarID, Filter, JD_num, CI, UntransformedMag) %>%
      arrange(JD_num)
    df_CI_points <- extractCI_points(df_targetStarID, CI_filters, transforms) %>% 
      arrange(JD_num)

    # Interpolate CI and put it in df_targetStarID
    i <- 0
    if (nrow(df_CI_points) == 0) {
      df_targetStarID$CI <- NA  # because there are no color index values to apply.
      cat(">>>>> ModelStarID=", thisTargetStarID, ": no CI points returned by imputeTargetCIs()\n", sep="")
    }
    if (nrow(df_CI_points) == 1) {
      df_targetStarID$CI <- df_CI_points$CI[1] # set all CI to the same value
    }
    if (nrow(df_CI_points) %in% 2:3) { # linear interpolation (with residuals if 3 points)
      m <- lm (CI ~ JD_num, data=df_CI_points)
      df_targetStarID$CI <- predict.lm(m, data.frame(JD_num=df_targetStarID$JD_num))
      # Enforce no extrapolation.
      df_targetStarID$CI[df_targetStarID$JD_num < df_CI_points$JD_num[1]] <- 
        predict.lm(m,data.frame(JD_num=df_CI_points$JD_num[1]))
      df_targetStarID$CI[df_targetStarID$JD_num > df_CI_points$JD_num[nrow(df_CI_points)]] <-
        predict.lm(m,data.frame(JD_num=df_CI_points$JD_num[nrow(df_CI_points)]))
    }
    if (nrow(df_CI_points) >= 4) { # make and apply smoothing spline (std package "stats").
      degrees_freedom <- round(nrow(df_CI_points)/6) %>% max(4) %>% min(nrow(df_CI_points))
      thisSpline <- smooth.spline(df_CI_points$JD_num, df_CI_points$CI, df=degrees_freedom)
      df_targetStarID$CI <- predict(thisSpline, df_targetStarID$JD_num)$y
      # Enforce no extrapolation.
      df_targetStarID$CI[df_targetStarID$JD_num < df_CI_points$JD_num[1]] <- 
        predict(thisSpline, df_CI_points$JD_num[1])$y
      df_targetStarID$CI[df_targetStarID$JD_num > df_CI_points$JD_num[nrow(df_CI_points)]] <-
        predict(thisSpline, df_CI_points$JD_num[nrow(df_CI_points)])$y
    }

    # Do the CI value replacements.
    df_predictions$CI[match(df_targetStarID$Serial, df_predictions$Serial)] <- df_targetStarID$CI
    i <- 0
  }
  return (df_predictions) # which now includes filled-in CI values and new column JD_num.
}

extractCI_points <- function (df, CI_filters, transforms) {
  ##### df must be a data frame from df_predictions, subset holding one ModelStarID.
  require(dplyr, quietly=TRUE)
  maxDiffJD <- 15 / (24*60) # max time between paired obs, in (Julian) days, typically 15 minutes.
  df <- df %>% filter(Filter %in% CI_filters) %>% arrange(JD_num)
  
  df_CI_point <- data.frame()
  for (iStart in 1:(nrow(df)-1)) {
    if (df$Filter[iStart+1] != df$Filter[iStart]) {
      if (df$JD_num[iStart+1]-df$JD_num[iStart] <= maxDiffJD) {
        this_JD_num <- (df$JD_num[iStart+1] + df$JD_num[iStart]) / 2
        # CI_predicted is color index from naive, predicted, untransformed (not catalog-basis) mags.
        CI_predicted <- ifelse(df$Filter[iStart]==CI_filters[1],
                               df$UntransformedMag[iStart]-df$UntransformedMag[iStart+1],
                               df$UntransformedMag[iStart+1]-df$UntransformedMag[iStart])
        this_CI <- CI_predicted / (1 + transforms[1] - transforms[2]) # transforms -> catalog-basis CI.
        df_CI_point <- df_CI_point %>% rbind(data.frame(JD_num=this_JD_num, CI=this_CI))
      } 
    }
  }
  return (df_CI_point)
}


